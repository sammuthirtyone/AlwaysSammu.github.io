<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Kitty Coin Catcher: Ultra Cute Edition</title>
    <meta name="description" content="A kawaii arcade game. Catch coins, avoid bombs, and collect skins!">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap');
        
        :root {
            --primary: #ff8fa3;
            --secondary: #5e548e;
            --accent: #ffb703;
            --text: #231942;
            --bg-grad: linear-gradient(180deg, #e0c3fc 0%, #8ec5fc 100%);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; font-family: 'Fredoka', sans-serif; }
        
        body {
            background: #1a1a2e;
            height: 100vh; width: 100vw;
            display: flex; align-items: center; justify-content: center; overflow: hidden;
        }

        /* Container designed to fit CrazyGames iframe constraints */
        .game-container {
            position: relative;
            width: 100%; height: 100%;
            max-width: 600px; max-height: 900px;
            background: var(--bg-grad);
            box-shadow: 0 0 40px rgba(0,0,0,0.5);
            overflow: hidden;
            display: flex; flex-direction: column;
        }

        @media (min-width: 601px) { .game-container { border-radius: 24px; height: 95vh; } }

        /* UI Overlay */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        .hud {
            padding: 20px; display: flex; justify-content: space-between; align-items: flex-start;
            pointer-events: auto;
        }

        .stat-pill {
            background: #fff; padding: 8px 16px; border-radius: 50px;
            border: 3px solid #fff;
            box-shadow: 0 6px 0 rgba(0,0,0,0.1);
            color: var(--secondary); font-weight: 700; font-size: 1.2rem;
            display: flex; align-items: center; gap: 8px;
            margin-bottom: 10px;
            transition: transform 0.1s;
        }

        .btn-round {
            width: 50px; height: 50px; border-radius: 50%; border: none;
            background: #fff; font-size: 1.5rem; cursor: pointer;
            box-shadow: 0 4px 0 #c8b6ff; color: var(--secondary);
            display: flex; align-items: center; justify-content: center;
            transition: all 0.1s;
        }
        .btn-round:active { transform: translateY(4px); box-shadow: none; }

        /* Screens */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(8px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 20; padding: 20px;
            transition: opacity 0.2s, visibility 0.2s;
            pointer-events: auto;
        }
        .hidden { opacity: 0; visibility: hidden; pointer-events: none; }

        h1 { 
            font-size: 3.2rem; color: var(--primary); text-align: center; 
            line-height: 1; text-shadow: 3px 3px 0 #fff, 6px 6px 0 rgba(0,0,0,0.1); 
            margin-bottom: 30px; 
            animation: bounce 2s infinite;
        }

        .btn-main {
            background: linear-gradient(to bottom, #ff8fa3, #ff5d8f);
            border: none; padding: 18px 60px; border-radius: 60px;
            font-size: 2rem; color: white; font-weight: 800; cursor: pointer;
            box-shadow: 0 8px 0 #c9184a, 0 15px 20px rgba(255, 93, 143, 0.4);
            margin: 10px; transition: 0.1s; width: 80%; max-width: 350px;
            text-transform: uppercase; letter-spacing: 2px;
        }
        .btn-main:active { transform: translateY(8px); box-shadow: 0 0 0 #c9184a; }
        
        .btn-sec {
            background: #fff; color: var(--secondary);
            border: 3px solid #efefef; padding: 12px 40px; border-radius: 40px;
            font-size: 1.3rem; font-weight: 700; cursor: pointer;
            box-shadow: 0 5px 0 #ddd; margin-top: 15px;
        }
        .btn-sec:active { transform: translateY(5px); box-shadow: none; }

        /* Shop Grid */
        .shop-container {
            background: #fff; border-radius: 20px; padding: 20px;
            width: 100%; max-width: 400px; max-height: 60vh;
            overflow-y: auto;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.05);
        }
        .shop-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; }
        
        .shop-item {
            background: #f8f9fa; padding: 15px; border-radius: 15px;
            text-align: center; border: 3px solid transparent;
            cursor: pointer; position: relative; transition: 0.2s;
        }
        .shop-item.owned { background: #e2eafc; }
        .shop-item.equipped { border-color: var(--primary); background: #ffe5ec; }
        .shop-item.locked { opacity: 0.6; filter: grayscale(1); }
        .shop-item:active { transform: scale(0.95); }

        canvas { display: block; width: 100%; height: 100%; }

        /* Animations */
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        .shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 10%, 90% { transform: translateX(-4px); } 50% { transform: translateX(4px); } }
    </style>
</head>
<body>

<div class="game-container" id="gameContainer">
    <div class="ui-layer">
        <div class="hud">
            <div>
                <div class="stat-pill" style="color: #ffb703;">ü™ô <span id="uiScore">0</span></div>
                <div class="stat-pill" style="color: #ff5d8f;" id="uiLives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
            </div>
            <button class="btn-round" id="btnPause">II</button>
        </div>
        
        <div style="position:absolute; bottom:20px; width:100%; text-align:center; opacity:0.6; font-weight:600; color: white; text-shadow: 1px 1px 0 rgba(0,0,0,0.2);">
            Slide to Move
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div class="screen" id="screenStart">
        <h1>KITTY<br>CATCH</h1>
        <button class="btn-main" id="btnPlay">PLAY</button>
        <button class="btn-sec" id="btnShop">üëó SKINS</button>
        <div style="margin-top:20px; display:flex; gap:20px;">
            <button class="btn-round" id="btnMute">üéµ</button>
        </div>
    </div>

    <div class="screen hidden" id="screenShop">
        <div class="hud" style="width:100%; position: absolute; top:0;">
            <button class="btn-round" id="btnCloseShop">‚úï</button>
            <div class="stat-pill">Wallet: <span id="uiWallet">0</span></div>
        </div>
        <h2 style="color:var(--secondary); margin-top: 50px; margin-bottom: 20px;">WARDROBE</h2>
        <div class="shop-container">
            <div class="shop-grid" id="shopGrid"></div>
        </div>
    </div>

    <div class="screen hidden" id="screenOver">
        <h1 style="font-size: 2.5rem; margin-bottom: 10px;">GAME OVER</h1>
        <div style="font-size: 4rem; font-weight:800; color:var(--primary); margin-bottom: 10px;">
            <span id="uiFinalScore">0</span>
        </div>
        <p style="color:#666; font-weight:bold; margin-bottom:30px;">BEST: <span id="uiBestScore">0</span></p>
        <button class="btn-main" id="btnRestart">AGAIN!</button>
        <button class="btn-sec" id="btnHome">MENU</button>
    </div>

    <div class="screen hidden" id="screenPause">
        <h1>PAUSED</h1>
        <button class="btn-main" id="btnResume">RESUME</button>
        <button class="btn-sec" id="btnQuit">QUIT</button>
    </div>
</div>

<script>
/**
 * KITTY CATCH - REFACTORED
 * Author: Gemini
 * Features: High DPI Canvas, Object Pooling logic, Smooth Audio, Responsive
 */

// --- CONFIGURATION ---
const CONSTANTS = {
    PLAYER_WIDTH: 70,
    PLAYER_HEIGHT: 55,
    GRAVITY: 800,
    COLORS: {
        coin: '#ffb703',
        bomb: '#ef233c',
        heart: '#ff8fa3',
        text: '#ffffff'
    }
};

const SKINS = [
    { id: 'classic', name: 'Classic', cost: 0, color: '#ffcdb2', type: 'cat' },
    { id: 'calico', name: 'Calico', cost: 100, color: '#e0aaff', type: 'cat' },
    { id: 'void', name: 'Void', cost: 300, color: '#343a40', type: 'cat' },
    { id: 'tiger', name: 'Tiger', cost: 500, color: '#ff9f1c', type: 'cat' },
    { id: 'alien', name: 'Gnarp', cost: 1000, color: '#70e000', type: 'alien' },
    { id: 'robo', name: 'Mecha', cost: 2000, color: '#adb5bd', type: 'robot' }
];

// --- STATE MANAGEMENT ---
const State = {
    screen: 'start', // start, play, pause, shop, over
    score: 0,
    lives: 3,
    coins: 0,
    bestScore: 0,
    inventory: ['classic'],
    equipped: 'classic',
    settings: { sound: true }
};

// --- AUDIO SYSTEM (Web Audio API) ---
const AudioSys = (() => {
    let ctx = null;
    let masterGain = null;
    let isInit = false;

    // Simple Synth Functions
    const playTone = (freq, type, dur, vol = 0.1, slide = 0) => {
        if (!State.settings.sound || !ctx) return;
        if (ctx.state === 'suspended') ctx.resume();
        
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        const t = ctx.currentTime;

        osc.type = type;
        osc.frequency.setValueAtTime(freq, t);
        if (slide) osc.frequency.exponentialRampToValueAtTime(slide, t + dur);

        gain.gain.setValueAtTime(vol, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + dur);

        osc.connect(gain);
        gain.connect(masterGain);
        osc.start();
        osc.stop(t + dur);
    };

    return {
        init: () => {
            if (isInit) return;
            const AC = window.AudioContext || window.webkitAudioContext;
            ctx = new AC();
            masterGain = ctx.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(ctx.destination);
            isInit = true;
        },
        resume: () => { if(ctx && ctx.state === 'suspended') ctx.resume(); },
        playJump: () => playTone(300, 'sine', 0.15, 0.1, 400),
        playCoin: () => {
            playTone(1200, 'sine', 0.1, 0.05); 
            setTimeout(() => playTone(1600, 'sine', 0.2, 0.05), 50); // "Ding-ding"
        },
        playBomb: () => playTone(150, 'sawtooth', 0.4, 0.2, 50),
        playLife: () => playTone(400, 'triangle', 0.3, 0.1, 800)
    };
})();

// --- GAME ENGINE ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
let animationId;
let lastTime = 0;
let scaleFactor = 1;

// Game Entities
const player = { x: 0, y: 0, vx: 0, targetX: 0, w: CONSTANTS.PLAYER_WIDTH, h: CONSTANTS.PLAYER_HEIGHT, squash: 1 };
let entities = []; // Coins, Bombs
let particles = [];
let floaters = []; // Floating Text
let clouds = []; // Background clouds

// --- HELPERS ---
const rand = (min, max) => Math.random() * (max - min) + min;
const lerp = (a, b, t) => a + (b - a) * t;

function resize() {
    const container = document.getElementById('gameContainer');
    const dpr = window.devicePixelRatio || 1;
    const rect = container.getBoundingClientRect();
    
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    
    ctx.scale(dpr, dpr);
    scaleFactor = dpr; // Use for touch calc
    
    // Internal Logical Width/Height
    canvas.logicalWidth = rect.width;
    canvas.logicalHeight = rect.height;

    // Reposition Player
    player.y = canvas.logicalHeight - 100;
    if(State.screen === 'start') player.x = canvas.logicalWidth/2 - player.w/2;
}

// --- LOGIC ---
function spawnEntity() {
    const roll = Math.random();
    let type = 'coin';
    if (roll > 0.85) type = 'bomb';
    else if (roll > 0.82 && State.lives < 3) type = 'heart';

    const size = type === 'bomb' ? 35 : 28;
    
    entities.push({
        x: rand(20, canvas.logicalWidth - 20),
        y: -50,
        type: type,
        w: size,
        h: size,
        speed: rand(200, 300) + (State.score * 2), // Diff ramp
        rot: rand(0, 360),
        rotSpeed: rand(-2, 2)
    });
}

function spawnParticles(x, y, color) {
    for(let i=0; i<8; i++) {
        particles.push({
            x: x, y: y,
            vx: rand(-150, 150),
            vy: rand(-150, 150),
            life: 1.0,
            color: color,
            size: rand(3, 8)
        });
    }
}

function spawnCloud() {
    clouds.push({
        x: rand(0, canvas.logicalWidth),
        y: rand(-50, canvas.logicalHeight/2),
        speed: rand(10, 30),
        size: rand(40, 80)
    });
}

function update(dt) {
    // Player Logic (Squash & Stretch + Lerp)
    const prevX = player.x;
    player.x = lerp(player.x, player.targetX, 10 * dt);
    
    // Clamp
    if (player.x < 0) player.x = 0;
    if (player.x > canvas.logicalWidth - player.w) player.x = canvas.logicalWidth - player.w;

    // Calculate velocity for squash effect
    const vel = Math.abs(player.x - prevX);
    const targetSquash = 1.0 - Math.min(vel * 0.005, 0.2); 
    player.squash = lerp(player.squash, targetSquash, 10 * dt);

    // Spawning
    if (Math.random() < 0.02 + (State.score * 0.0001)) spawnEntity();
    if (Math.random() < 0.005 && clouds.length < 5) spawnCloud();

    // Entities Loop
    for (let i = entities.length - 1; i >= 0; i--) {
        let e = entities[i];
        e.y += e.speed * dt;
        e.rot += e.rotSpeed * dt;

        // Collision (Circle to Rect approximation)
        // Hitbox padding: easier to catch coins, harder to hit bombs
        const padding = e.type === 'bomb' ? 10 : -10; 
        
        if (
            e.y + e.h > player.y + 10 &&
            e.y < player.y + player.h &&
            e.x + e.w > player.x + padding &&
            e.x < player.x + player.w - padding
        ) {
            handleCollision(e);
            entities.splice(i, 1);
            continue;
        }

        if (e.y > canvas.logicalHeight) entities.splice(i, 1);
    }

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.life -= dt * 2;
        if(p.life <= 0) particles.splice(i, 1);
    }

    // Floaters
    for (let i = floaters.length - 1; i >= 0; i--) {
        floaters[i].y -= 50 * dt;
        floaters[i].life -= dt;
        if(floaters[i].life <= 0) floaters.splice(i, 1);
    }

    // Clouds
    for (let c of clouds) {
        c.x += c.speed * dt;
        if(c.x > canvas.logicalWidth + 100) c.x = -100;
    }
}

function handleCollision(e) {
    if (e.type === 'coin') {
        State.score += 10;
        AudioSys.playCoin();
        spawnParticles(e.x, e.y, CONSTANTS.COLORS.coin);
        floaters.push({x: e.x, y: e.y, text: "+10", color: "#fff", life: 0.8});
    } else if (e.type === 'bomb') {
        State.lives--;
        AudioSys.playBomb();
        spawnParticles(e.x, e.y, CONSTANTS.COLORS.bomb);
        floaters.push({x: e.x, y: e.y, text: "OUCH", color: CONSTANTS.COLORS.bomb, life: 0.8});
        
        // Visual Shake
        const con = document.getElementById('gameContainer');
        con.classList.remove('shake');
        void con.offsetWidth; // Trigger reflow
        con.classList.add('shake');

        if (State.lives <= 0) endGame();
    } else if (e.type === 'heart') {
        State.lives++;
        AudioSys.playLife();
        floaters.push({x: e.x, y: e.y, text: "‚ù§Ô∏è", color: CONSTANTS.COLORS.heart, life: 0.8});
    }
    updateUI();
}

// --- RENDERING ---
function draw() {
    // 1. Background
    ctx.fillStyle = '#C8B6FF'; 
    ctx.fillRect(0, 0, canvas.logicalWidth, canvas.logicalHeight);
    
    // Draw Clouds
    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
    for(let c of clouds) {
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.size, 0, Math.PI * 2);
        ctx.arc(c.x + c.size*0.7, c.y - c.size*0.5, c.size*0.8, 0, Math.PI * 2);
        ctx.arc(c.x + c.size*1.2, c.y, c.size*0.9, 0, Math.PI * 2);
        ctx.fill();
    }

    // 2. Player (The Cute Cat)
    const skin = SKINS.find(s => s.id === State.equipped);
    const px = player.x;
    const py = player.y + (player.h * (1 - player.squash)); // Anchor bottom
    const pw = player.w;
    const ph = player.h * player.squash;

    ctx.save();
    ctx.translate(px + pw/2, py + ph/2); // Center pivot
    
    // Body
    ctx.fillStyle = skin.color;
    ctx.beginPath();
    // Rounded rect
    ctx.roundRect(-pw/2, -ph/2, pw, ph, 15);
    ctx.fill();
    // Border
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(0,0,0,0.1)";
    ctx.stroke();

    // Ears
    ctx.beginPath();
    ctx.moveTo(-pw/2 + 5, -ph/2 + 5);
    ctx.lineTo(-pw/2 - 5, -ph/2 - 15);
    ctx.lineTo(-pw/2 + 25, -ph/2 + 5);
    ctx.moveTo(pw/2 - 5, -ph/2 + 5);
    ctx.lineTo(pw/2 + 5, -ph/2 - 15);
    ctx.lineTo(pw/2 - 25, -ph/2 + 5);
    ctx.fill();

    // Face
    const eyeOffset = (player.targetX - player.x) * 0.05;
    ctx.fillStyle = "#333";
    // Eyes
    ctx.beginPath();
    ctx.ellipse(-15 + eyeOffset, -5, 4, 6, 0, 0, Math.PI*2);
    ctx.ellipse(15 + eyeOffset, -5, 4, 6, 0, 0, Math.PI*2);
    ctx.fill();
    // Mouth
    ctx.beginPath();
    ctx.arc(0 + eyeOffset, 5, 3, 0, Math.PI, false);
    ctx.stroke();
    // Blush
    ctx.fillStyle = "rgba(255,100,100,0.3)";
    ctx.beginPath();
    ctx.arc(-20, 5, 5, 0, Math.PI*2);
    ctx.arc(20, 5, 5, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();

    // 3. Entities
    for(let e of entities) {
        ctx.save();
        ctx.translate(e.x + e.w/2, e.y + e.h/2);
        ctx.rotate(e.rot);
        
        if (e.type === 'coin') {
            // Gold Circle
            ctx.fillStyle = "#ffcc00";
            ctx.beginPath();
            ctx.arc(0, 0, e.w/2, 0, Math.PI*2);
            ctx.fill();
            // Inner Shine
            ctx.fillStyle = "#ffe066";
            ctx.beginPath();
            ctx.arc(-5, -5, e.w/4, 0, Math.PI*2);
            ctx.fill();
            // Outline
            ctx.strokeStyle = "#e59500";
            ctx.lineWidth = 2;
            ctx.stroke();
            // Symbol
            ctx.fillStyle = "#e59500";
            ctx.font = "bold 16px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("$", 0, 1);
        } else if (e.type === 'bomb') {
            // Black Body
            ctx.fillStyle = "#2b2d42";
            ctx.beginPath();
            ctx.arc(0, 0, e.w/2, 0, Math.PI*2);
            ctx.fill();
            // Fuse
            ctx.strokeStyle = "#8d99ae";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, -e.w/2);
            ctx.lineTo(5, -e.w/2 - 8);
            ctx.stroke();
            // Spark
            ctx.fillStyle = "#ef233c";
            ctx.beginPath();
            ctx.arc(5, -e.w/2 - 8, 3, 0, Math.PI*2);
            ctx.fill();
            // Skull
            ctx.fillStyle = "#8d99ae";
            ctx.font = "14px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("‚ò†Ô∏è", 0, 2);
        } else if (e.type === 'heart') {
             ctx.fillStyle = "#ff8fa3";
             ctx.font = "24px Arial";
             ctx.textAlign = "center";
             ctx.textBaseline = "middle";
             ctx.fillText("‚ù§Ô∏è", 0, 0);
        }

        ctx.restore();
    }

    // 4. Particles
    for(let p of particles) {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }

    // 5. Floating Text
    for(let f of floaters) {
        ctx.globalAlpha = Math.max(0, f.life);
        ctx.fillStyle = f.color;
        ctx.font = "bold 20px Fredoka";
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 3;
        ctx.strokeText(f.text, f.x, f.y);
        ctx.fillText(f.text, f.x, f.y);
        ctx.globalAlpha = 1.0;
    }
}

// --- GAME LOOP ---
function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dt = Math.min((timestamp - lastTime) / 1000, 0.1); // Cap dt
    lastTime = timestamp;

    if (State.screen === 'play') {
        update(dt);
        draw();
    }
    
    animationId = requestAnimationFrame(loop);
}

// --- INPUT HANDLERS ---
function setPlayerPos(clientX) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width; // Should be dpr
    const relX = (clientX - rect.left);
    
    // Center the player on the mouse/touch
    player.targetX = relX - player.w/2;
}

canvas.addEventListener('mousemove', e => {
    if (State.screen === 'play') setPlayerPos(e.clientX);
});

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (State.screen === 'play') setPlayerPos(e.touches[0].clientX);
}, { passive: false });

// Keyboard
window.addEventListener('keydown', e => {
    if (State.screen !== 'play') return;
    const speed = 40;
    if (e.key === 'ArrowLeft' || e.key === 'a') player.targetX -= speed;
    if (e.key === 'ArrowRight' || e.key === 'd') player.targetX += speed;
});

// --- UI FUNCTIONS ---
function updateUI() {
    document.getElementById('uiScore').innerText = State.score;
    let hearts = "";
    for(let i=0; i<3; i++) hearts += i < State.lives ? "‚ù§Ô∏è" : "üñ§";
    document.getElementById('uiLives').innerText = hearts;
}

function startGame() {
    State.score = 0;
    State.lives = 3;
    entities = [];
    particles = [];
    floaters = [];
    player.targetX = canvas.logicalWidth/2 - player.w/2;
    player.x = player.targetX;
    
    toggleScreen('play');
    updateUI();
    AudioSys.resume();
}

function endGame() {
    State.coins += State.score;
    if(State.score > State.bestScore) State.bestScore = State.score;
    saveData();
    
    document.getElementById('uiFinalScore').innerText = State.score;
    document.getElementById('uiBestScore').innerText = State.bestScore;
    toggleScreen('over');
}

function toggleScreen(name) {
    State.screen = name;
    document.querySelectorAll('.screen').forEach(el => el.classList.add('hidden'));
    document.querySelector('.ui-layer').style.opacity = name === 'play' ? 1 : 0;
    
    if(name === 'start') document.getElementById('screenStart').classList.remove('hidden');
    if(name === 'shop') document.getElementById('screenShop').classList.remove('hidden');
    if(name === 'over') document.getElementById('screenOver').classList.remove('hidden');
    if(name === 'pause') document.getElementById('screenPause').classList.remove('hidden');
}

// Shop Logic
function renderShop() {
    const grid = document.getElementById('shopGrid');
    grid.innerHTML = "";
    document.getElementById('uiWallet').innerText = State.coins;

    SKINS.forEach(skin => {
        const owned = State.inventory.includes(skin.id);
        const equipped = State.equipped === skin.id;
        
        const el = document.createElement('div');
        el.className = `shop-item ${owned ? 'owned' : ''} ${equipped ? 'equipped' : ''} ${!owned && State.coins < skin.cost ? 'locked' : ''}`;
        el.innerHTML = `
            <div style="font-size:2rem; margin-bottom:5px;">${skin.type === 'alien' ? 'üëΩ' : skin.type === 'robot' ? 'ü§ñ' : 'üò∫'}</div>
            <div style="font-weight:bold; color: ${skin.color}; text-shadow: 1px 1px 0 #000;">${skin.name}</div>
            <div style="font-size:0.8rem; color:#666;">${owned ? (equipped ? 'EQUIPPED' : 'OWNED') : 'ü™ô '+skin.cost}</div>
        `;
        
        el.onclick = () => {
            if (owned) {
                State.equipped = skin.id;
                AudioSys.playCoin();
            } else if (State.coins >= skin.cost) {
                State.coins -= skin.cost;
                State.inventory.push(skin.id);
                State.equipped = skin.id;
                AudioSys.playLife();
            } else {
                return; // Can't afford
            }
            saveData();
            renderShop();
        };
        grid.appendChild(el);
    });
}

// --- SAVE SYSTEM ---
function loadData() {
    const d = localStorage.getItem('kittyCatchData');
    if(d) {
        const p = JSON.parse(d);
        State.coins = p.coins || 0;
        State.bestScore = p.bestScore || 0;
        State.inventory = p.inventory || ['classic'];
        State.equipped = p.equipped || 'classic';
    }
}
function saveData() {
    localStorage.setItem('kittyCatchData', JSON.stringify({
        coins: State.coins,
        bestScore: State.bestScore,
        inventory: State.inventory,
        equipped: State.equipped
    }));
}

// --- INITIALIZATION ---
window.onload = () => {
    resize();
    AudioSys.init();
    loadData();
    window.addEventListener('resize', resize);
    
    // Button Bindings
    document.getElementById('btnPlay').onclick = startGame;
    document.getElementById('btnRestart').onclick = startGame;
    
    document.getElementById('btnShop').onclick = () => { toggleScreen('shop'); renderShop(); };
    document.getElementById('btnCloseShop').onclick = () => toggleScreen('start');
    document.getElementById('btnHome').onclick = () => toggleScreen('start');
    
    document.getElementById('btnPause').onclick = () => toggleScreen('pause');
    document.getElementById('btnResume').onclick = () => { toggleScreen('play'); lastTime = performance.now(); };
    document.getElementById('btnQuit').onclick = () => toggleScreen('start');

    document.getElementById('btnMute').onclick = (e) => {
        State.settings.sound = !State.settings.sound;
        e.target.innerText = State.settings.sound ? "üéµ" : "üîá";
    };

    // Pre-seed clouds
    for(let i=0; i<3; i++) spawnCloud();

    requestAnimationFrame(loop);
};

</script>
</body>
</html>
